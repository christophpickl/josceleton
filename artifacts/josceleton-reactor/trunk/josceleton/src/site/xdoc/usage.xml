
	// TODO @SITE somewhere document how josceleton can be accessed (as guice is used internally)
	// following options are possible, on how to access josceleton:
	//		a) invoke logic directly via static Josceleton facade (bad style, bad for testing, static cling)
	//		b) create facade statically once, and only pass instance type (good enough, but still could be improved)
	//		c) use guice yourself (pay attention to dependency mess)
	//		d) use spring // TO DO have to implement a bridge or something
	//		.) ... some other DI framework?!
	
//	final Module module = new JosceletonGuiceModule();
//	final Injector injector = Guice.createInjector(module);
//	final JosceletonFacade facade = new JosceletonFacadeImpl(injector);
//	... = facade.openConnection();
//
//	final Injector injector = Guice.createInjector(new JosceletonGuiceModule());
//	final JosceletonFacade facade = new JosceletonFacadeImpl(injector);
//	... = facade.openConnection();
//	
//	final JosceletonFacade facade = new JosceletonFacadeImpl(Josceleton.newGuiceInjector());
//	... = facade.openConnection();
//
//	final JosceletonFacade facade = new JosceletonFacadeImpl(Josceleton.newGuiceInjector());
//	... = facade.openConnection();
//
//	final JosceletonFacade facade = Josceleton.newFacade();
//	... = facade.openConnection();
	
	/** Just some sample code. */
	public static void main(final String[] args) {
		Connection connection = Josceleton.openConnection();
		
		connection.addListener(new ConnectionListener() {
			
			public void onUserMessage(UserMessage message) {
				System.out.println("Received a user message: " + message);
			}
			
			public void onJointMessage(JointMessage message) {
				// this will be invoked quiet often ;)
				System.out.println("Received a joint message: " + message);
			}
		});
		
		System.out.println("Running ...");
		
//		as we are dealing with an async message (event) driven environment, have to close connection "somewhen"
//		connection.close();
	}